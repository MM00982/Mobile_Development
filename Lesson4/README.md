# Практическая работа №4

## Глава 1. Привязка графических компонентов

В первой главе рассмотрен приём использования View Binding на примере интерфейса музыкального плеера.
View Binding был активирован в файле build.gradle. В макете activity\_main.xml были добавлены элементы управления: 
EditText, TextView и кнопки Play/Stop, которым присвоены идентификаторы через атрибут android\:id.
В классе MainActivity был создан объект ActivityMainBinding, после чего корневое представление было 
установлено с помощью метода setContentView(binding.getRoot()). Доступ к элементам управления осуществлялся через свойства объекта 
binding: выполнено заполнение поля EditText и назначен обработчик событий для кнопки воспроизведения, в котором использовался Log.d().
Для поддержки горизонтальной ориентации был создан альтернативный макет activity\_main\_land.xml. Класс ActivityMainBinding автоматически 
сгенерировался с той же структурой полей, что позволило обеспечить корректную работу интерфейса в обеих ориентациях экрана без использования метода findViewById.

![image_2025-05-28_15-42-03](https://github.com/user-attachments/assets/292da090-bc15-4519-b733-2a1bac9063b6)
![image_2025-05-28_15-42-20](https://github.com/user-attachments/assets/4085bfef-f7dc-4dc8-b1fb-5c6740bad32e)

---

## Глава 2. Основные понятия асинхронной работы в Android

Во 2-й главе был реализован вынос ресурсоёмких вычислений за пределы главного потока с целью расчёта среднего количества учебных пар в день.
Был создан модуль с Activity, на экране размещены два поля ввода (общее количество пар и число учебных дней), кнопка запуска расчёта и элемент TextView для отображения результата.
Также выводилось имя главного потока, обозначение группы, порядковый номер и наименование любимого фильма.
В журнале Logcat для каждого созданного потока фиксировались сообщения вида: «Запущен поток №1 студентом группы № БСБО-09-22 номер по списку № 18», а по завершении — «Выполнен поток №1».

![image_2025-05-28_18-10-23](https://github.com/user-attachments/assets/40385590-76d0-4d77-84ea-c3decac14e03)
![image_2025-05-28_18-09-49](https://github.com/user-attachments/assets/ff4bc2b3-ef58-44d3-971f-61ae8c36ef45)

---

## Глава 3. Передача данных между потоками

В 3-й главе было рассмотрено сразу три механизма обмена данными и сообщений.
### Задание 1
В модуле с именем data_thread создан поток, который последовательно вызывает runOnUiThread(runn1), затем view.post(runn2), а затем view.postDelayed(runn3, 2000).
На экране отображается последовательное обновление: сначала runn1, затем сразу runn2, и через две секунды — runn3.

![image_2025-05-28_18-34-31](https://github.com/user-attachments/assets/35e84ab7-cf8c-4321-9905-635c1e041525)

### Задание 2
В модуле looper реализован отдельный класс MyLooper с собственным объектом Handler и очередью MessageQueue.
Кнопка пользовательского интерфейса отправляет текстовое сообщение, MyLooper вычисляет длину строки, формирует ответ и отправляет его обратно в основной поток.

![image_2025-05-28_18-42-34](https://github.com/user-attachments/assets/aa2270e6-6fd6-4bca-9242-72d031ca9ed3)

### Задание 3
В модуле CryptoLoader вводится строка, которая по нажатию кнопки шифруется с использованием AES-ключа, сформированного через KeyGenerator.
Шифрованные данные вместе с ключом помещаются в Bundle и передаются в AsyncTaskLoader.
В методе loadInBackground() выполняется дешифровка и возврат исходного текста, который отображается с помощью Toast.

![image_2025-05-28_18-52-27](https://github.com/user-attachments/assets/0c6bec74-2b9c-4229-8622-1af2562d6f72)
![image_2025-05-28_18-52-42](https://github.com/user-attachments/assets/6e502692-5de0-4ac7-9b60-457e5d0fc142)

---

## Глава 4. Сервис

Был реализован сервис воспроизведения аудио, который в методе onCreate() инициализирует объект MediaPlayer с треком из каталога res/raw. 
В onStartCommand() сервис переводится в режим foreground с помощью вызова startForeground(1, notification). 
Для отображения уведомления создан NotificationChannel и собран экземпляр NotificationCompat.Builder. 
Запуск сервиса осуществляется по нажатию на кнопку воспроизведения в пользовательском интерфейсе, остановка — по кнопке завершения. 
В фоновом режиме воспроизведение продолжается даже после сворачивания приложения. По окончании трека слушатель OnCompletionListener 
удаляет уведомление и вызывает stopForeground(true), обеспечивая корректное завершение работы.

![image_2025-05-28_19-11-07](https://github.com/user-attachments/assets/47564b4f-de40-4351-90c8-d3ecbbe395a6)
![image_2025-05-28_19-11-21](https://github.com/user-attachments/assets/978480d7-e2ce-49fa-a636-7d14f13cc435)

---

## Глава 5. WorkManager

В 5-й главе была рассмотрена библиотека WorkManager и реализована примерная фоновая задача.
В проект добавлена зависимость `androidx.work`.
Создан класс `UploadWorker`, имитирующий выполнение работы в течение 10 секунд.
Заданы ограничения `Constraints` — подключение к неограниченной сети Wi-Fi и наличие зарядки.
Сформирован `OneTimeWorkRequest` и отправлен на выполнение через `WorkManager.enqueue()`.
По логам зафиксировано начало и завершение `doWork()`, что подтвердило запуск задачи только при соблюдении заданных условий.


![image_2025-05-28_19-19-03](https://github.com/user-attachments/assets/a713db8a-fbca-4088-8690-13f4ae1e2495)

---

## Глава 6. Контрольное задание

В основном проекте MireaProject был добавлен фрагмент Background Task.
Пользователь нажимает Execute — создаётся OneTimeWorkRequest.
Ход выполнения отслеживается через LiveData<WorkInfo> или собственное состояние сервиса; по завершении выводится результат Snackbar’ом.

![image_2025-05-28_19-33-42](https://github.com/user-attachments/assets/54048cb3-f996-421e-9476-2c0246d553d8)

---

## Вывод

Была освоена безопасная привязка разметки к коду без использования `findViewById`, реализован вынос ресурсоёмких вычислений в 
отдельные потоки с последующим надёжным возвратом результатов в UI. Освоены механизмы `Handler`/`Looper` и `AsyncTaskLoader` на примере 
шифрования AES. Реализован сервис-плеер с управлением воспроизведением музыки через уведомление. Освоено планирование фоновых задач с 
использованием `WorkManager`. В завершение все рассмотренные подходы были объединены в итоговом задании — создана долгоживущая фоновая 
задача с опорой на современную архитектуру Android.

---

**Выполнил**: Мусин М.Р.  
**Группа**: БСБО-09-22
